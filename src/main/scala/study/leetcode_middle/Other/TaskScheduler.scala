package study.leetcode_middle.Other

/**
  * Task Scheduler
  * 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
  *
  * 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
  *
  * 你需要计算完成所有任务所需要的最短时间。
  *
  * 示例 1：
  *
  * 输入: tasks = ["A","A","A","B","B","B"], n = 2
  * 输出: 8
  * 执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
  * 注：
  *
  * 任务的总个数为 [1, 10000]。
  * n 的取值范围为 [0, 100]。
  */
object TaskScheduler {
  /**
    * 直译本题就是任务规划，题目的核心意思是，安排一堆任务，这些任务由一个task数组给出，相同任务之间，最少有n的运行时间间隔，在n的运行时间间隔内，可以执行执行别的任务或者处于就绪状态。最终的目标是安排所有的task，使总的运行时间最小。
    * 对于两个相同的task，我们假设都为A，两者之间的最小间隔是n，这就是题目想表达的含义，我们首先考虑出现频率最高的task，我们仍假设为A，出现的频率为x，我们知道，要满足A的时间需求，我们至少应该有 x-1个n的间隔。对于频率小于x的任务，假设为B，我们按序插入任务B，可以发现，这样的插入也是满足要求的。满足A的最小安排，最终所有的任务安排都是满足要求的（先不考虑任务多得插不进去的情况）。
    * 因为出现频率最高的元素可能不止一个，我们假设为k个，那么这种情况下最终的时间需求为：
    * (x-1)*n+k
    *
    * 若出现完全插满的情况，上式仍然成立，但显然，多余的task没有计算。这时候我们观察形成的序列，如果完全插满，这时候的时间需求显然就是整个数组的大小了。
    *
    * @param tasks
    * @param n
    * @return
    */
  def leastInterval(tasks: Array[Char], n: Int): Int = {
    val chArr = new Array[Int](26)
    tasks.foreach {
      t =>
        chArr(t - 'A') += 1
    }
    val c = chArr.sorted
    var i = 25
    while (i >= 0 && c(i) == c(25)) i -= 1
    tasks.length.max((c(25) - 1) * (n + 1) + 25 - i)
  }

}
